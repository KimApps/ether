package com.kimapps.signing.wallet_connect

import com.reown.android.Core
import com.reown.android.CoreClient
import com.reown.walletkit.client.Wallet
import com.reown.walletkit.client.WalletKit
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject
import javax.inject.Singleton

/**
 * WalletConnectManager - Central hub for all WalletConnect session logic.
 *
 * Implements [WalletKit.WalletDelegate] to receive asynchronous callbacks
 * from the SDK and translates them into reactive Kotlin flows that the
 * ViewModel can collect.
 *
 * Responsibilities:
 * 1. **Pairing** – accepts a `wc:` URI and initiates the CoreClient handshake.
 * 2. **Session approval** – auto-approves incoming session proposals with a
 *    fixed Ethereum mainnet namespace (suitable for a mock/demo wallet).
 * 3. **Request routing** – emits incoming session requests (e.g. `personal_sign`)
 *    through [sessionRequests] so the ViewModel can surface the approval dialog.
 * 4. **Request responses** – sends signed results or rejection errors back to
 *    the dApp via [WalletKit.respondSessionRequest].
 * 5. **Connection state** – keeps [isConnected] up to date so the UI can
 *    reactively switch between the pairing input and the connected card.
 *
 * Marked [@Singleton] so the same instance is shared across the entire app
 * process, ensuring callbacks from the SDK always reach the active ViewModel.
 *
 * @param applicationScope A [CoroutineScope] tied to the application lifetime
 *                         (not a ViewModel scope) so session-request emissions
 *                         survive ViewModel recreation.
 */
@Singleton
class WalletConnectManager @Inject constructor(
    private val applicationScope: CoroutineScope,
) : WalletKit.WalletDelegate {

    // ─────────────────────────────────────────────
    // Public reactive state
    // ─────────────────────────────────────────────

    /**
     * Backing [MutableStateFlow] — only this class can flip the connected flag.
     * True when a WalletConnect session is fully settled; false after deletion.
     */
    private val _isConnected = MutableStateFlow(false)

    /**
     * Read-only view of the connection state.
     * Collected by the ViewModel to drive the WalletConnectSection UI state:
     * - false → show pairing input
     * - true  → show "Wallet Connected ✅" confirmation card
     */
    val isConnected = _isConnected.asStateFlow()

    /**
     * Backing [MutableSharedFlow] with no replay — each session request is
     * delivered to exactly the one active collector (the ViewModel).
     * SharedFlow (vs Channel) is used so missed emissions during ViewModel
     * recreation are dropped rather than queued indefinitely.
     */
    private val _sessionRequests = MutableSharedFlow<Wallet.Model.SessionRequest>()

    /**
     * Read-only stream of incoming session requests from the paired dApp.
     * Each emission represents one `personal_sign` (or similar) call that
     * the user must Approve or Reject via the [SigningApprovalDialog].
     */
    val sessionRequests = _sessionRequests.asSharedFlow()

    // ─────────────────────────────────────────────
    // Public API
    // ─────────────────────────────────────────────

    /**
     * Initiates a WalletConnect pairing using the URI the user pasted.
     * The URI must start with `wc:` and be freshly generated by a dApp —
     * URIs are single-use and expire after a short window.
     *
     * On success the SDK emits [onSessionProposal] which is auto-approved
     * in this manager, eventually triggering [onSessionSettleResponse].
     *
     * @param uri The raw `wc:` pairing URI copied from the dApp's QR code or link.
     */
    fun pair(uri: String) {
        val pairParams = Core.Params.Pair(uri)
        CoreClient.Pairing.pair(pairParams) { error ->
            // Pairing can fail if the URI is expired, malformed, or already used.
            // In production, surface this error to the UI via an error state.
            println("Pairing Error: ${error.throwable.stackTraceToString()}")
        }
    }

    /**
     * Sends a successful JSON-RPC result back to the dApp for the given request.
     * Called after the user taps "Approve" in the [SigningApprovalDialog].
     *
     * Uses request.request.id (not a hardcoded value) so the dApp can match
     * the response to the exact request it sent.
     *
     * @param request   The original session request received from the dApp.
     * @param signature The signature string to return as the JSON-RPC result.
     */
    fun approveRequest(request: Wallet.Model.SessionRequest, signature: String) {
        val response = Wallet.Params.SessionRequestResponse(
            sessionTopic = request.topic,
            jsonRpcResponse = Wallet.Model.JsonRpcResponse.JsonRpcResult(
                // Must match the request ID so the dApp can correlate the response
                id = request.request.id,
                result = signature
            )
        )
        WalletKit.respondSessionRequest(
            params = response,
            onSuccess = { println("WalletConnect: request approved successfully") },
            onError = { error -> println("WalletConnect: approve error ${error.throwable}") }
        )
    }

    /**
     * Sends a JSON-RPC error back to the dApp for the given request.
     * Called after the user taps "Reject" in the [SigningApprovalDialog].
     *
     * Error code 4001 is the EIP-1193 standard code for "User Rejected Request",
     * which well-behaved dApps recognise and handle gracefully.
     *
     * @param request The original session request to reject.
     */
    fun rejectRequest(request: Wallet.Model.SessionRequest) {
        val response = Wallet.Params.SessionRequestResponse(
            sessionTopic = request.topic,
            jsonRpcResponse = Wallet.Model.JsonRpcResponse.JsonRpcError(
                id = request.request.id,
                code = 4001,   // EIP-1193: User Rejected Request
                message = "User rejected the request"
            )
        )
        WalletKit.respondSessionRequest(
            params = response,
            onSuccess = { println("WalletConnect: request rejected") },
            onError = { error -> println("WalletConnect: reject error ${error.throwable}") }
        )
    }

    // ─────────────────────────────────────────────
    // WalletKit.WalletDelegate callbacks
    // All methods below are called by the SDK on a background thread.
    // ─────────────────────────────────────────────

    /**
     * Triggered when a dApp sends a session proposal after pairing completes.
     *
     * This implementation **auto-approves** every proposal with a fixed
     * Ethereum mainnet (eip155:1) namespace using a mock account address.
     * In a production wallet the user would be shown a confirmation UI and
     * could choose which accounts/chains to expose.
     *
     * On approval the SDK emits [onSessionSettleResponse] to confirm the session.
     */
    override fun onSessionProposal(
        sessionProposal: Wallet.Model.SessionProposal,
        verifyContext: Wallet.Model.VerifyContext
    ) {
        // Build the namespace map that this wallet agrees to support.
        // "eip155" is the CAIP-2 namespace for all EVM-compatible chains.
        val namespaces = mapOf(
            "eip155" to Wallet.Model.Namespace.Session(
                chains = listOf("eip155:1"),   // Ethereum mainnet only
                methods = listOf(
                    "personal_sign",           // Primary method used by this app
                    "eth_sendTransaction",
                    "eth_signTransaction"
                ),
                events = listOf("accountsChanged", "chainChanged"),
                accounts = listOf("eip155:1:0x57f48fAFeC1d76B27e3f29b8d277b6218CDE6092") // Mock account
            )
        )

        // proposerPublicKey identifies the specific dApp session being approved
        val approveParams = Wallet.Params.SessionApprove(sessionProposal.proposerPublicKey, namespaces)
        WalletKit.approveSession(approveParams) { error ->
            // In production, update UI state to show the user that approval failed
            println("Approve Session Error: $error")
        }
    }

    /**
     * Triggered when the dApp sends a signing request (e.g. `personal_sign`)
     * on the active session.
     *
     * Emits the request into [_sessionRequests] using the application-scoped
     * coroutine so the emission is not cancelled if the ViewModel is recreated
     * (e.g. during a configuration change).
     * The ViewModel collects this and stores it in SigningState.pendingRequest,
     * causing [SigningApprovalDialog] to appear.
     */
    override fun onSessionRequest(
        sessionRequest: Wallet.Model.SessionRequest,
        verifyContext: Wallet.Model.VerifyContext
    ) {
        applicationScope.launch {
            // Emit on applicationScope — survives ViewModel recreation
            _sessionRequests.emit(sessionRequest)
        }
    }

    /**
     * Triggered when the dApp or the user explicitly deletes the session.
     * Resets the connected flag so the UI returns to the pairing-input state.
     */
    override fun onSessionDelete(sessionDelete: Wallet.Model.SessionDelete) {
        _isConnected.value = false
    }

    /**
     * Triggered after [WalletKit.approveSession] completes and the session
     * is fully established on the relay network.
     *
     * Checks the response type to distinguish success from failure:
     * - SettledSessionResponse.Result → session is live, mark as connected.
     * - SettledSessionResponse.Error  → approval failed, stay disconnected.
     */
    override fun onSessionSettleResponse(settleSessionResponse: Wallet.Model.SettledSessionResponse) {
        _isConnected.value = settleSessionResponse is Wallet.Model.SettledSessionResponse.Result
    }

    /**
     * Triggered when the session expiry is extended via [WalletKit.extendSession].
     * Not used in this implementation — sessions use their default 7-day lifetime.
     */
    override fun onSessionExtend(session: Wallet.Model.Session) {}

    /**
     * Triggered with the dApp's response after [WalletKit.updateSession] is called.
     * Not used in this implementation — session namespaces are fixed at approval time.
     */
    override fun onSessionUpdateResponse(sessionUpdateResponse: Wallet.Model.SessionUpdateResponse) {}

    /**
     * Triggered whenever the relay WebSocket connection state changes
     * (e.g. connected, disconnected, connecting).
     * Logged here for debugging; in production this could drive a
     * connectivity banner in the UI.
     */
    override fun onConnectionStateChange(state: Wallet.Model.ConnectionState) {
        println("WalletConnect connection state: $state")
    }

    /**
     * Triggered when the SDK encounters an internal error not tied to a
     * specific callback (e.g. relay message decryption failure).
     * In production, send to Crashlytics for diagnosis.
     */
    override fun onError(error: Wallet.Model.Error) {
        println("WalletConnect Error: ${error.throwable}")
    }
}